// Error handling utilities\n\nexport class AppError extends Error {\n  public readonly code: string;\n  public readonly statusCode?: number;\n  public readonly isOperational: boolean;\n  public readonly timestamp: string;\n\n  constructor(\n    message: string,\n    code: string,\n    statusCode?: number,\n    isOperational = true\n  ) {\n    super(message);\n    this.name = 'AppError';\n    this.code = code;\n    this.statusCode = statusCode;\n    this.isOperational = isOperational;\n    this.timestamp = new Date().toISOString();\n\n    // Capture stack trace\n    Error.captureStackTrace(this, AppError);\n  }\n}\n\n// Predefined error types\nexport const ErrorCodes = {\n  // Network errors\n  NETWORK_ERROR: 'NETWORK_ERROR',\n  API_ERROR: 'API_ERROR',\n  TIMEOUT_ERROR: 'TIMEOUT_ERROR',\n  \n  // Validation errors\n  VALIDATION_ERROR: 'VALIDATION_ERROR',\n  INVALID_INPUT: 'INVALID_INPUT',\n  \n  // Authentication errors\n  AUTH_ERROR: 'AUTH_ERROR',\n  UNAUTHORIZED: 'UNAUTHORIZED',\n  \n  // Application errors\n  UNKNOWN_ERROR: 'UNKNOWN_ERROR',\n  COMPONENT_ERROR: 'COMPONENT_ERROR',\n  HOOK_ERROR: 'HOOK_ERROR',\n} as const;\n\n// Error factory functions\nexport const createNetworkError = (message: string, statusCode?: number) => \n  new AppError(message, ErrorCodes.NETWORK_ERROR, statusCode);\n\nexport const createValidationError = (message: string) => \n  new AppError(message, ErrorCodes.VALIDATION_ERROR, 400);\n\nexport const createAuthError = (message: string) => \n  new AppError(message, ErrorCodes.AUTH_ERROR, 401);\n\n// Error handler utility\nexport const handleError = (error: unknown, context?: string): AppError => {\n  let appError: AppError;\n\n  if (error instanceof AppError) {\n    appError = error;\n  } else if (error instanceof Error) {\n    appError = new AppError(\n      error.message,\n      ErrorCodes.UNKNOWN_ERROR,\n      undefined,\n      false\n    );\n    appError.stack = error.stack;\n  } else {\n    appError = new AppError(\n      'An unknown error occurred',\n      ErrorCodes.UNKNOWN_ERROR,\n      undefined,\n      false\n    );\n  }\n\n  // Log the error\n  console.error(`Error in ${context || 'unknown context'}:`, {\n    message: appError.message,\n    code: appError.code,\n    statusCode: appError.statusCode,\n    stack: appError.stack,\n    timestamp: appError.timestamp,\n  });\n\n  return appError;\n};\n\n// Async error handler\nexport const handleAsyncError = async <T>(\n  fn: () => Promise<T>,\n  context?: string\n): Promise<T> => {\n  try {\n    return await fn();\n  } catch (error) {\n    throw handleError(error, context);\n  }\n};\n\n// Error retry utility\nexport const withRetry = async <T>(\n  fn: () => Promise<T>,\n  options: {\n    maxAttempts?: number;\n    delay?: number;\n    backoff?: boolean;\n    context?: string;\n  } = {}\n): Promise<T> => {\n  const {\n    maxAttempts = 3,\n    delay = 1000,\n    backoff = true,\n    context = 'unknown'\n  } = options;\n\n  let lastError: Error;\n  \n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n      \n      if (attempt === maxAttempts) {\n        throw handleError(lastError, `${context} (after ${maxAttempts} attempts)`);\n      }\n      \n      // Calculate delay with optional backoff\n      const currentDelay = backoff ? delay * Math.pow(2, attempt - 1) : delay;\n      \n      console.warn(`Attempt ${attempt} failed in ${context}, retrying in ${currentDelay}ms:`, lastError.message);\n      \n      await new Promise(resolve => setTimeout(resolve, currentDelay));\n    }\n  }\n  \n  throw handleError(lastError!, context);\n};\n\n// Error boundary helpers\nexport const isOperationalError = (error: unknown): boolean => {\n  return error instanceof AppError && error.isOperational;\n};\n\nexport const shouldReportError = (error: unknown): boolean => {\n  if (error instanceof AppError) {\n    return !error.isOperational || error.statusCode === undefined || error.statusCode >= 500;\n  }\n  return true;\n};\n\n// Error formatting utilities\nexport const formatErrorForUser = (error: unknown): string => {\n  if (error instanceof AppError) {\n    switch (error.code) {\n      case ErrorCodes.NETWORK_ERROR:\n        return 'Unable to connect to the server. Please check your internet connection.';\n      case ErrorCodes.VALIDATION_ERROR:\n        return error.message;\n      case ErrorCodes.AUTH_ERROR:\n        return 'Authentication failed. Please log in again.';\n      default:\n        return 'An unexpected error occurred. Please try again.';\n    }\n  }\n  \n  return 'An unexpected error occurred. Please try again.';\n};\n\nexport const formatErrorForDeveloper = (error: unknown): object => {\n  if (error instanceof AppError) {\n    return {\n      name: error.name,\n      message: error.message,\n      code: error.code,\n      statusCode: error.statusCode,\n      isOperational: error.isOperational,\n      timestamp: error.timestamp,\n      stack: error.stack,\n    };\n  }\n  \n  if (error instanceof Error) {\n    return {\n      name: error.name,\n      message: error.message,\n      stack: error.stack,\n    };\n  }\n  \n  return {\n    error: String(error),\n  };\n};